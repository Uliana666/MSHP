<h1 style="text-align: center;">Теория чисел 1</h1>

## <span style="color: #c5f015"> E. Что живет на планете?  </span>

<details>
    <summary>Hint 1</summary>

Вам нужно посчитать сколько чисел массива $a$ делятся, на каждое простое. И вывести количество простых, на которые поделились ровно один. (Обратите внимение, что даже если одно число делится много раз на $p$, все равно считается что $p$ встретилось 1 раз)

</details>


<details>
    <summary>Hint 2</summary>

Решение влоб: \
За $O(\sqrt C)$ можем найти все простые числа на которое делится конкретное число $a_i$, и соответствующе пересчитать счетчик. Получили решение за $O(n \cdot \sqrt C)$. Такое решение получит ТЛ, подумайте о том, как можно было бы быстрее факторизовать числа (найти все простые делители).

</details>

<details>
    <summary>Hint 3</summary>

Воспользуемся решетом Эратосфена. В самом начале кода (например еще до ввода чисел) найдем все простые числа от $1$ до $\sqrt C$ за $O(\sqrt C \cdot \ln( \sqrt C))$. Тогда для того, что факторизовать число нам нужно пройтись только на нашему массиву найденх простых чисел и проверить делится или нет. Здесь важно что вы должны также ИДТИ ДО КОРНЯ из числа. Вот пример кода:

```c++
while (x > 1 && cur < p.size() && p[cur] * p[cur] <= x) {
			if (x % p[cur] == 0) {
				while (x % p[cur] == 0) {
					x /= p[cur];
                    // p[cur] - делитель

				}
			}
			++cur;
		}
		if (x > 1) {
			// x - тоже делитель
		}

```
$p$ - массив простых чисел полученных после выполнение решета Эратосфена. Не забывайте, что так как мы идем до корня, также как и в исходном алгоритме факторизации нельзя забывать про оставшийся кусок $х$.

</details>

## <span style="color: #c5f015"> F. Псевдопростые представления </span>

<details>
    <summary>Hint 1</summary>

Данная задача является просто задачей на перебор. Вспомните как лучше писать переборы.

</details>

<details>
    <summary>Hint 2</summary>

Сначала факторизуем число, как в одной из прошлых задач. И запишем эти делители в порядке сортировки (чтобы равные шли подряд). Далее для каждого делители нужно выбрать знак ('+' или '-'). Причем так, чтобы итоговый знак произведения совпал со знаком нашего числа. Также, обратите внимание, что $2 \cdot (-2)$ и $(-2) \cdot 2$ являются одинаковыми способами. Таким образом, стоит считать, что среди подряд идущих делителей, какие-то первые имеют знак '+', а оставшиеся знак '-'.

</details>

<details>
    <summary>Hint 3</summary>

Напоминание о том как писать переборы: \
Это нужно делать с помощью рекурсии и какой-нибудь глобальной переменной. В данной задаче будет удобно:

```c++

vector<int> divs; // Вектор для делителей числа
vector<int> div_sign; // Вектор для знаков делителей
int n_sign; // Знак числа n
 
void rec(int i, int sign) { // В переборах мы в рекурсии всегда 
// фиксируем на каком моменте мы (у какого делителя выбираем 
// знак) - i и какой итоговый знак набран sgn
	if (i == divs.size()) { // Для всех выбрали
		if (sign == n_sign) { // Только если знак правильный, что просят в задаче
			// Выведите ответ
		}
		return;
	}
    // Сами придумайте какое условие здесь должно быть
	if (TODO) {
		div_sign[i] = 1;
        // Переберем варианты где тут знак '+'
		go(i + 1, sign);
	}
	div_sign[i] = -1;
    // И варианты где тут знак '-'
	go(i + 1, -sign);
}

```

</details>


## <span style="color: #c5f015"> G. Сумма и произведения </span>

<details>
    <summary>Hint 1</summary>

Подумайте о количестве делителей числа $B$.

</details>

<details>
    <summary>Hint 2</summary>

Вспомним как мы ищем все делителя числа за $O(\sqrt N)$И поймем, что делителей числа $B$ в нашей задаче "мало" - $O(\sqrt B)$. Таким образом давайте просто переберем все возможные способы получить $B$ из произведения трех чисел (3 вложеннхы фора) и проверим что их сумма равна $A$.

</details>
