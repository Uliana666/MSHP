<h1 style="text-align: center;">STL</h1>

## <span style="color: #c5f015"> E. EuroEnglish  </span>

<details>
    <summary>Hint 1</summary>

Данная задача на реализацию и в каком-то смысле на силу рук. Советы для простоты написания:
1. Разделите весь текст по пробелам и разделительным символам, то есть считайте массив слов.
2. Для каждого слова можно сделать метку, начинается оно с большой буквы или нет. А после сделать первую букву маленькой во всех словах.
3. Выделите все в как можно большее количество функций. Логику когда всегда хорошо разделять.
4. Для проверки на артикли используйте
    ```c++
    if (s == "an" || s == "a" || s == "the")
    ```
    А не посимвольное сравнение.

</details>


## <span style="color: #c5f015"> F. Конец сессии </span>

<details>
    <summary>Hint 1</summary>

Подумайте в каком порядке оптимально есть чизкейки.

</details>

<details>
    <summary>Hint 2</summary>

Нет смысла идти к более даленьму чизкейку, а потом возвращаться к более ближнему. Таким образом мы будем просто идти по прямой слева направо и есть какие-то чизкейки. Пусть мы зафиксировали координату $x$ (среди координат чизкейков) на которой закончится время. Какое максимальное количество чизкейков мы могли съесть?

</details>

<details>
    <summary>Hint 3</summary>

На каждой координате $x$ нам нужно решить задачу: Какое максимальное количество чизкейков мы съедим, если у нас есть время $T' = T - x$.
Причем нам известен массив $t_1, t_2, ..., t_k$
Если бы решали втупую для каждой $x$, то мы бы отсортировали массив $t$. И набирали самые быстро съедаемые чизкейки пока есть время.

</details>

<details>
    <summary>Hint 4</summary>

Чтобы быстрее решать задачу для каждых $x$ можно использовать сет для поддержания самых быстро съедаемых чизкейков. Нужно подумать что будет происходить когда будет появляться новый чизкейк, когда мы переходим на новую координату. И что будет происходить из-за уменьшения доступного времени на поедание.

</details>

## <span style="color: #c5f015"> G. K-ый максимум </span>

<details>
    <summary>Hint 1</summary>

В стандартной бибилиотеки с++ нет подходящей структуры для решения данной задачи. К сожалнию ни set, ни map не умеют искать быстро $k$-ый по счету элемент.\
Все движения по итератору, например ```a.begin() + k``` или ```prev(a.end(), k)``` работают за $O(k)$

</details>

<details>
    <summary>Hint 2</summary>
Используйте ordered_set:

```c++
#include <ext/pb_ds/assoc_container.hpp>

#include <ext/pb_ds/tree_policy.hpp>

 

using namespace __gnu_pbds;

 

typedef tree<int, null_type, std::less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;

int main() {
    ordered_set x;
    x.insert(-num);
    x.erase(-num);
    find_by_order(num)
}
```

</details>

## <span style="color: #c5f015"> H. (Не)человек с каменным сердцем </span>

<details>
    <summary>Hint 1</summary>

В задаче требуется идти окном длины $m$ по массиву и собрать как можно больше наборов. \
Подумайте о том, как оптимально собирать наборы.

</details>

<details>
    <summary>Hint 2</summary>

Заметим, что достаточно просто жадно собирать наборы. То есть, ли мы понимаем, что на текущий позиции встречаются карты всех типов, то нужно просто для каждого типа брать карту, которая быстрее всех пропадет, то есть имеющая наименьший индекс. \
Подумайте, какая структура и как позволила бы делать это быстро.

</details>

<details>
    <summary>Hint 3</summary>

Будем хранить для каждого типа карты хранить set с позициями (доступными в текущем окне). А так же поддерживать количество различных карт на окне. \
Как на основе этой информации собрать наборы?

</details>

<details>
    <summary>Hint 4</summary>

На текущей позиции окна будем создавать наборы и удалять карты из set-ов. То есть пока различных карт $k$, будем за $O(k)$ пробегаться по всем сетам и брать оттуда карту с минимальным номером ($*s.begin()$), причем если какой-то из сетов стал пустым, это значит нужно уменьшить количество различных доступных карт. Далее, при сдвиге на 1 вправо нужно учесть то, что пропадает 1 карта и появляется 1 новая. Так повторяем процесс, пока не дойдем до конца массива.

</details>

## <span style="color: #c5f015"> I. Взрывные котята </span>

<details>
    <summary>Hint 1</summary>

Для почти всех котов верно, что сли кот с числом $x$ выключен, то и все коты с таким числом должны быть выключены. Таким образом нас интересует лишь количество котов для каждого числа. \
Подумайте, когда это неверно.

</details>

<details>
    <summary>Hint 2</summary>

Почти все числа разбиваются на пары, сумма которых в паре дает ровно $k$. Таким образом, в каждой паре нужно будет оставить лишь одно число, то есть одну кучку котов. Нужно выбрать оптимально.

</details>

<details>
    <summary>Hint 3 (Распространенная ошибка)</summary>

Когда рассуждения от Hint 1 и Hint 2 неверны. Если $k$ - четно, то число $\frac{k}{2}$ образует пару как бы с самим собой. И на самом деле, мы проиграем если таких чисел будет хотя бы 2. То есть, если у нас есть одно такое число это не страшно. Таким образом, нужно выключать не всех $p$ котов с таким числом, а только $p-1$.

</details>

## <span style="color: #c5f015"> J. Вирусное видео </span>

<details>
    <summary>Hint 1</summary>

Подумайте о том, как можно быстро (за $O(n)$) проверять, где нужно разомкнуть последовательность.

</details>

<details>
    <summary>Hint 2</summary>

Последовательность нужно размыкать всегда перед той позицией, где находится единица. Осталось лишь пройтись и проверить, что то, что получилось отсортировано. Однако это решение за $O(q\cdot n)$. Подумайте о том, какую информацию можно хранить кроме как для каждой позиции какое число там лежит. (Просто хранить массив а).\
Подумайте о том, что если $1$ находится на позиции $x$, то на какой позиции должна находится $2$? а $n$?

</details>

<details>
    <summary>Hint 3</summary>

Давайте для каждого числа $i$ от $1$ до $n$ хранить число $b_i = (pos_i - i + n)\mod n$, где $pos_i$ - индекс (в 1 нумерации) в массиве где находится число $i$. Заметим, что $b_i$ есть сдвиг (всегда неотрицательный) от позиции где должно было стоять число $i$, если бы массив выглядел как $1, 2, ..., n$. \
Подумайте, как на основе этой информации понимать можно ли разрезать массив, так чтобы он был отсортирован.

</details>

<details>
    <summary>Hint 4</summary>

Заметим, что все подходящие массивы выглядят как:
$$1, 2, 3, ..., n$$
$$n, 1, 2, ..., n-1$$
$$n-1, n, 1, 2, ..., n-2$$
$$\vdots$$
$$2, 3, ..., n-1, n, 1$$
Их и только их характеризует то, что это циклические сдвиги $1, 2, ..., n$. То есть мы сдвинули на 1 по циклу все элементы. То есть сдвиг от их исходной позиции увеличился на 1. Причем у всех одинаковый.\
Тогда ответ на задачу ДА, когда $b_1 = b_2 = ... = b_n$. \
Осталось придумать как быстро это проверять.

</details>

<details>
    <summary>Hint 5</summary>

Будем хранить multiset $b_i$-ых. При свапе двух элементов, меняются значения ровно двух элементов массива $b$ - Делается за $O(2 logn)$ Тогда чтобы проверить, что $b_1 = b_2 = ... = b_n$, достаточно проверить, что минимум равен максимуму в массиве $b$. Что легко делается с помощью multiset.

</details>